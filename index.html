<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CCTV 12권역 모니터링</title>

  <style>
    :root{
      --bg:#0b0b0c;
      --panel:rgba(255,255,255,.06);
      --border:rgba(255,255,255,.10);
      --border2:rgba(255,255,255,.16);
      --text:#fff;
      --muted:rgba(255,255,255,.65);
      --headerH:72px;
      --gap:10px;
      --radius:14px;
    }

    html, body { height:100%; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:var(--bg);
      color:var(--text);
      overflow:hidden; /* 페이지 자체 스크롤 방지 */
    }

    header{
      position: sticky; top:0; z-index:100;
      height: var(--headerH);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; flex-wrap:wrap;

      padding:12px 14px;
      background: rgba(11,11,12,.85);
      backdrop-filter: blur(8px);
      border-bottom: 1px solid rgba(255,255,255,.08);
      box-sizing: border-box;
    }
    .title{ font-weight:800; font-size:14px; letter-spacing:.2px; }
    .sub{ font-size:12px; color:var(--muted); }

    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .btn{
      font-size:12px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border2);
      background: rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
      text-decoration:none;
      white-space:nowrap;
    }
    .btn:hover{ border-color: rgba(255,255,255,.28); background: rgba(255,255,255,.10); }

    /* ✅ 관제 그리드: "페이지 단위" 표시이므로 스크롤을 없애고, 화면에 딱 맞게 */
    .grid{
      height: calc(100vh - var(--headerH));
      padding: var(--gap);
      box-sizing:border-box;

      display:grid;
      grid-template-columns: repeat(4, minmax(260px, 1fr)); /* 4열 유지 */
      gap: var(--gap);

      overflow:hidden; /* ✅ 페이지 스크롤 X (넘김으로만 이동) */
      grid-auto-rows: minmax(420px, auto);
      align-items:start;
    }
    @media (max-width: 1200px){ .grid{ grid-template-columns: repeat(3, minmax(240px, 1fr)); } }
    @media (max-width: 900px) { .grid{ grid-template-columns: repeat(2, minmax(240px, 1fr)); } }
    @media (max-width: 520px) { .grid{ grid-template-columns: 1fr; } }

    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: 0 8px 30px rgba(0,0,0,.25);
      display:flex;
      flex-direction:column;
      min-height: 240px;
    }

    .cardHead{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:10px 10px 8px;
      border-bottom:1px solid rgba(255,255,255,.08);
      box-sizing:border-box;
    }
    .meta{ display:flex; flex-direction:column; gap:4px; min-width:0; }
    .region{ font-weight:800; font-size:13px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .note{ font-size:11px; color:var(--muted); line-height:1.3; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    .headBtns{ display:flex; gap:6px; }
    .pill{
      font-size:11px;
      padding:6px 8px;
      border-radius:999px;
      border:1px solid var(--border2);
      background: rgba(255,255,255,.06);
      color:var(--text);
      text-decoration:none;
      cursor:pointer;
      white-space:nowrap;
    }
    .pill:hover{ border-color: rgba(255,255,255,.28); background: rgba(255,255,255,.10); }

    .frameWrap{
      position:relative;
      background:#111;
      aspect-ratio: 4 / 3;
      width:100%;
      min-height: 260px;
      flex:none;
    }
    iframe{
      position:absolute; inset:0;
      width:100%;
      height:100%;
      border:0;
      background:#111;
    }

    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding:14px;
      text-align:center;
      color: rgba(255,255,255,.78);
      font-size:12px;
      background: linear-gradient(0deg, rgba(0,0,0,.62), rgba(0,0,0,.38));
      opacity:0;
      pointer-events:none;
      transition: opacity .15s ease;
    }
    .overlay.show{ opacity:1; pointer-events:auto; }
    .overlay .box{
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      border-radius:12px;
      padding:10px 12px;
      max-width:340px;
    }
    .overlay .box b{ color:#fff; }
    .overlay .actions{ margin-top:8px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap; }

    .toast{
      position:fixed; left:50%; bottom:14px; transform:translateX(-50%);
      background: rgba(0,0,0,.7);
      border: 1px solid rgba(255,255,255,.14);
      color:#fff;
      padding:10px 12px;
      border-radius:12px;
      font-size:12px;
      opacity:0;
      transition: opacity .2s ease;
      pointer-events:none;
      z-index:200;
      max-width: 92vw;
      white-space: pre-line;
    }
    .toast.show{ opacity:1; }

    /* ✅ 페이지 전환 감성(관제 느낌): 살짝 페이드 */
    .grid.fadeOut{ opacity:.18; transition: opacity .18s ease; }
    .grid.fadeIn{ opacity:1; transition: opacity .18s ease; }
  </style>
</head>

<body>
  <header>
    <div>
      <div class="title">CCTV 모니터링</div>
      <div class="sub" id="statusText">데이터 로딩 중…</div>
    </div>

    <div class="controls">
      <button class="btn" id="reloadPage">현재 페이지 리로드</button>
      <button class="btn" id="reloadAll">전체 리로드</button>

      <button class="btn" id="prevPage">◀ 이전</button>
      <button class="btn" id="nextPage">다음 ▶</button>

      <button class="btn" id="togglePageAuto">페이지 자동넘김: OFF</button>
      <span class="sub" id="pageInfo">-</span>

      <span class="sub">페이지당</span>
      <button class="btn" id="minusPerPage">-</button>
      <span class="sub" id="perPageText">8개</span>
      <button class="btn" id="plusPerPage">+</button>

      <span class="sub">간격</span>
      <button class="btn" id="minusSec">-</button>
      <span class="sub" id="secText">10초</span>
      <button class="btn" id="plusSec">+</button>

      <button class="btn" id="toggleReloadOnPage">페이지 넘김 시 리로드: OFF</button>
    </div>
  </header>

  <div class="grid" id="grid"></div>
  <div class="toast" id="toast"></div>

  <script>
    const CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vTZZaK8GDz_FZsefh-XoCkPmQhKOugjSRNioC5M8fAUH87iiyQV8KK28wCVN4_dbWJukM-Rbwkkbz_G/pub?gid=1422576665&single=true&output=csv";

    const grid = document.getElementById("grid");
    const statusText = document.getElementById("statusText");
    const toast = document.getElementById("toast");

    const reloadAllBtn = document.getElementById("reloadAll");
    const reloadPageBtn = document.getElementById("reloadPage");
    const prevPageBtn = document.getElementById("prevPage");
    const nextPageBtn = document.getElementById("nextPage");

    const togglePageAutoBtn = document.getElementById("togglePageAuto");
    const pageInfo = document.getElementById("pageInfo");

    const minusPerPageBtn = document.getElementById("minusPerPage");
    const plusPerPageBtn = document.getElementById("plusPerPage");
    const perPageText = document.getElementById("perPageText");

    const minusSecBtn = document.getElementById("minusSec");
    const plusSecBtn = document.getElementById("plusSec");
    const secText = document.getElementById("secText");

    const toggleReloadOnPageBtn = document.getElementById("toggleReloadOnPage");

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add("show");
      setTimeout(()=>toast.classList.remove("show"), 2200);
    }

    function escapeHtml(s){
      return String(s || "")
        .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
        .replace(/"/g,"&quot;").replace(/'/g,"&#039;");
    }
    function escapeAttr(s){
      return String(s || "")
        .replace(/&/g,"&amp;").replace(/"/g,"&quot;")
        .replace(/</g,"&lt;").replace(/>/g,"&gt;");
    }

    function parseCsv(text){
      const rows = [];
      let row = [], cur = "", inQ = false;
      for (let i=0; i<text.length; i++){
        const ch = text[i];
        const next = text[i+1];

        if (ch === '"' ){
          if (inQ && next === '"'){ cur += '"'; i++; }
          else inQ = !inQ;
          continue;
        }

        if (!inQ && ch === ","){
          row.push(cur); cur=""; continue;
        }

        if (!inQ && (ch === "\n" || ch === "\r")){
          if (ch === "\r" && next === "\n") i++;
          row.push(cur); cur="";
          if (row.some(c => String(c||"").trim() !== "")) rows.push(row);
          row = [];
          continue;
        }
        cur += ch;
      }
      if (cur.length || row.length){
        row.push(cur);
        if (row.some(c => String(c||"").trim() !== "")) rows.push(row);
      }
      return rows;
    }

    function normalizeHeaders(h){
      return String(h||"").trim().toLowerCase()
        .replace(/\s+/g,"")
        .replace(/[\u200b-\u200d\uFEFF]/g,"");
    }

    function mapCsvToItems(rows){
      if (!rows || rows.length < 2) return [];
      const header = rows[0];
      const idx = {};
      header.forEach((h, i) => idx[normalizeHeaders(h)] = i);

      const iRegion = idx["region"] ?? idx["권역"] ?? idx["지역"] ?? 0;
      const iUrl    = idx["url"] ?? idx["링크"] ?? idx["cctv"] ?? idx["주소"] ?? 1;
      const iNote   = idx["note"] ?? idx["비고"] ?? idx["설명"] ?? 2;

      return rows.slice(1)
        .map(r => ({
          region: String(r[iRegion] ?? "").trim(),
          url: String(r[iUrl] ?? "").trim(),
          note: String(r[iNote] ?? "").trim()
        }))
        .filter(x => x.region && x.url);
    }

    function withCacheBust(url){
      if (!url) return "";
      try{
        const u = new URL(url);
        u.searchParams.set("_t", Date.now());
        return u.toString();
      }catch(e){
        return url + (url.includes("?") ? "&" : "?") + "_t=" + Date.now();
      }
    }

    function buildCard(item, idx){
      const region = item.region || "-";
      const note = item.note || "";
      const url = item.url || "";

      const card = document.createElement("div");
      card.className = "card";
      card.dataset.region = region;
      card.dataset.url = url;

      card.innerHTML = `
        <div class="cardHead">
          <div class="meta">
            <div class="region">${escapeHtml(region)}</div>
            <div class="note">${note ? escapeHtml(note) : "&nbsp;"}</div>
          </div>
          <div class="headBtns">
            <a class="pill" href="${escapeAttr(url)}" target="_blank" rel="noopener noreferrer">새창</a>
            <button class="pill" data-action="reload">리로드</button>
          </div>
        </div>

        <div class="frameWrap">
          <iframe data-idx="${idx}" src="${escapeAttr(withCacheBust(url))}" loading="lazy"></iframe>

          <div class="overlay" id="ov_${idx}">
            <div class="box">
              <b>이 화면이 안 보일 수 있어요</b><br/>
              사이트 보안 정책으로 iframe이 차단된 경우입니다.<br/>
              <div class="actions">
                <a class="pill" href="${escapeAttr(url)}" target="_blank" rel="noopener noreferrer">새창으로 보기</a>
                <button class="pill" data-action="hide">닫기</button>
              </div>
            </div>
          </div>
        </div>
      `;

      card.querySelector('[data-action="reload"]')?.addEventListener("click", () => {
        const iframe = card.querySelector("iframe");
        if (!iframe) return;
        iframe.src = withCacheBust(iframe.src);
      });

      card.querySelector('[data-action="hide"]')?.addEventListener("click", () => {
        const ov = card.querySelector(".overlay");
        if (ov) ov.classList.remove("show");
      });

      return card;
    }

    // -----------------------------
    // ✅ 페이징(관제 페이지 넘김)
    // -----------------------------
    let allItems = [];
    let page = 0;

    // 기본값(요청: 관제처럼 "페이지 단위로 넘기기")
    let perPage = 8;          // 한 페이지당 카드 수
    let pageAutoOn = false;   // 자동 넘김
    let pageSec = 10;         // 자동 넘김 간격(초)
    let pageAutoTimer = null;

    // 페이지 이동 시, 현재 페이지 iframe만 리로드할지(옵션)
    let reloadOnPage = false;

    function totalPages(){
      return Math.max(1, Math.ceil(allItems.length / perPage));
    }

    function clampPage(){
      const tp = totalPages();
      if (page < 0) page = tp - 1;
      if (page >= tp) page = 0;
    }

    function renderPage({fade=true} = {}){
      clampPage();
      const tp = totalPages();
      const start = page * perPage;
      const end = start + perPage;
      const slice = allItems.slice(start, end);

      const now = new Date();
      statusText.textContent =
        `표시 ${allItems.length}개 · 마지막 로드: ${now.toLocaleString("ko-KR")} · (시트 수정 시 새로고침하면 반영)`;

      pageInfo.textContent = `페이지 ${page+1}/${tp} · ${perPage}개/페이지`;

      if (fade){
        grid.classList.remove("fadeIn");
        grid.classList.add("fadeOut");
      }

      setTimeout(() => {
        grid.innerHTML = "";
        slice.forEach((item, idx) => {
          // idx는 페이지 기준이 아니라 전체 기준이 overlay id에 쓰일 수 있어 겹치지 않게 글로벌 인덱스 사용
          const globalIdx = start + idx;
          grid.appendChild(buildCard(item, globalIdx));
        });

        grid.classList.remove("fadeOut");
        grid.classList.add("fadeIn");

        if (reloadOnPage){
          reloadCurrentPage();
        }
      }, fade ? 140 : 0);
    }

    function goNextPage(){
      page++;
      renderPage();
      showToast("다음 페이지");
    }
    function goPrevPage(){
      page--;
      renderPage();
      showToast("이전 페이지");
    }

    function reloadAll(){
      // 현재 렌더링된 iframe 포함, 전체 items 기준으로 "현재 페이지"만 보이므로
      // 전체 리로드는 '현재 페이지 iframe'도 리로드하고,
      // 그리고 다음 페이지로 넘어가도 새로 src가 구성될 때 cacheBust로 새로고침됨.
      document.querySelectorAll(".card iframe").forEach(iframe => {
        iframe.src = withCacheBust(iframe.src);
      });
      showToast("전체 리로드(현재 화면) 완료");
    }

    function reloadCurrentPage(){
      document.querySelectorAll(".card iframe").forEach(iframe => {
        iframe.src = withCacheBust(iframe.src);
      });
      showToast("현재 페이지 리로드 완료");
    }

    function setPageAuto(on){
      pageAutoOn = on;
      togglePageAutoBtn.textContent = "페이지 자동넘김: " + (pageAutoOn ? "ON" : "OFF");

      if (pageAutoTimer) clearInterval(pageAutoTimer);
      pageAutoTimer = null;

      if (pageAutoOn){
        pageAutoTimer = setInterval(() => {
          goNextPage();
        }, pageSec * 1000);
        showToast("페이지 자동넘김 ON");
      }else{
        showToast("페이지 자동넘김 OFF");
      }
    }

    function setReloadOnPage(on){
      reloadOnPage = on;
      toggleReloadOnPageBtn.textContent = "페이지 넘김 시 리로드: " + (reloadOnPage ? "ON" : "OFF");
      showToast(reloadOnPage ? "페이지 전환 시 리로드 ON" : "페이지 전환 시 리로드 OFF");
    }

    function updatePerPageUI(){
      perPageText.textContent = perPage + "개";
      renderPage({fade:false});
    }
    function updateSecUI(){
      secText.textContent = pageSec + "초";
      if (pageAutoOn){
        setPageAuto(true); // 타이머 재설정
      }
    }

    async function loadAndRender(){
      grid.innerHTML = "";
      statusText.textContent = "CSV 로딩 중…";

      try{
        const res = await fetch(CSV_URL, { cache: "no-store" });
        if (!res.ok) throw new Error("CSV HTTP " + res.status);
        const text = await res.text();

        const rows = parseCsv(text);
        const items = mapCsvToItems(rows);

        if (!items.length){
          statusText.textContent = "CSV 데이터가 비어있거나(또는 컬럼명이 다름) 표시할 항목이 없습니다.";
          return;
        }

        allItems = items;
        page = 0;
        renderPage({fade:false});
      }catch(e){
        statusText.textContent = "로딩 실패: " + (e.message || e);
      }
    }

    // -----------------------------
    // ✅ 이벤트 바인딩
    // -----------------------------
    reloadAllBtn.addEventListener("click", reloadAll);
    reloadPageBtn.addEventListener("click", reloadCurrentPage);
    nextPageBtn.addEventListener("click", () => {
      if (!pageAutoOn) goNextPage();
      else goNextPage();
    });
    prevPageBtn.addEventListener("click", () => {
      if (!pageAutoOn) goPrevPage();
      else goPrevPage();
    });

    togglePageAutoBtn.addEventListener("click", () => setPageAuto(!pageAutoOn));

    minusPerPageBtn.addEventListener("click", () => {
      // 최소 4개, 최대 24개(너무 과하면 가독성 떨어져서 제한)
      perPage = Math.max(4, perPage - 4);
      updatePerPageUI();
    });
    plusPerPageBtn.addEventListener("click", () => {
      perPage = Math.min(24, perPage + 4);
      updatePerPageUI();
    });

    minusSecBtn.addEventListener("click", () => {
      pageSec = Math.max(3, pageSec - 1);
      updateSecUI();
    });
    plusSecBtn.addEventListener("click", () => {
      pageSec = Math.min(60, pageSec + 1);
      updateSecUI();
    });

    toggleReloadOnPageBtn.addEventListener("click", () => setReloadOnPage(!reloadOnPage));

    // 키보드(관제실 느낌): ←/→ 로 페이지 이동, space로 자동넘김 토글
    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight") { e.preventDefault(); goNextPage(); }
      if (e.key === "ArrowLeft")  { e.preventDefault(); goPrevPage(); }
      if (e.key === " ")          { e.preventDefault(); setPageAuto(!pageAutoOn); }
      if (e.key.toLowerCase() === "r") { e.preventDefault(); reloadCurrentPage(); }
    });

    // 초기 UI
    perPageText.textContent = perPage + "개";
    secText.textContent = pageSec + "초";
    toggleReloadOnPageBtn.textContent = "페이지 넘김 시 리로드: OFF";

    loadAndRender();
  </script>
</body>
</html>
